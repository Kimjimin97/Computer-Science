# SSR VS CSR

- Q. SSR과 CSR

  ```
    웹 화면을 보여주기 위해서는 html, css, javscript의 코드를 렌더링 해야합니다.

    SSR의 경우는 서버측에서 최종적으로 렌더링된 html을 전달합니다.
    클라이언트에서 바로 화면에 전달받은 html파일을 보여주고, js 파일을 다운로드 받아 서버와 상호작용을 합니다.
    
    이미 완성된 페이지를 로딩하기 때문에, 초기 로딩 속도가 빠르고, 검색 엔진 최적화에서 향상된 성능을 제공합니다. 하지만, 화면을 이동할 때, 깜밖임을 보일 수 있고, 동적 컨텐츠 처리에 있어서 서버 부하가 진행될 수 있습니다.

    CSR은 클라이언트 즉 브라우저에서 렌더링을 시작합니다. 
    서버에게서 받은 초기 html 파일 전송 받습니다. 
    렌더링이 이전의 상태이기 때문에 사용자 입장에서는 처음에는 빈 페이지를 보고 있습니다. 
    이후, 브라우저는 css, javascript 파일을 다운로드 받고, html을 파싱하여 화면에 보여줍니다.

    필요한 데이터만 렌더링 되기 때문에 자연스러운 사용자 경험을 제공합니다.
    하지만, 한번에 모든 리소스를 제공받기 때문에 초기 로딩 속도가 느린 단점이 있습니다.
  ```

- Q. SSR의 과정을 자세히

  ```
    1. 사용자가 서버에 http 요청을 보낸다.
    2. 서버는 페이지를 만들어 나간다. 이때 필요한 data fetching을 통해서 빈 페이지가 아닌 초기 로딩된  완전한 페이지를 만들어준다.
    3. 브라우저 이 html파일을 바로 dom에 그리며 사용자에게 화면을 보여준다.
    4. 동시에 url을 통해 전송 받은 js를 다운로드 합니다.
    5. 로딩된 js를 실행시킨다.
    6. 동적인 페이지 구성이 완료된다.
    ```

- Q. SSR의 장단점

    ```
    장점
    - 완전한 html 파일을 가져오고 바로 사용자들에게 보여주기 때문에 초기 로딩 속도가 빠르다.
    - 때문에, 검색엔진최적화 성능이 높다.

    단점
    - 페이지 이동시 깜밖임이 존재한다. 전체 페이지를 렌더링을 시작하기 때문이다.
    - 페이지를 이동할 때 마다, 서버가 렌더링을 해야하기 때문에 서버 부하가 높다.
    - 불필요한 로딩이 존재한다.

    ```

- Q. CSR의 과정을 자세히

    ```
    1. 사용자가 url 요청을 통해 서버에게 http 요청을 진행한다.
    2. 서버는 html을 전송한다. 이후 클라이언트는 필요에 따라 js, css를 다운로드한다.
    3. 클라이언트는 브라우저를 통해 html 파일을 파싱한다. (react의 경우에는 virtualdom에 콘텐츠를  렌더링하고 dom에 붙인다.)
    4. 이 과정에서 JS 파일을 다운로드하고 실행합니다. 이후 JS에 의해 동적인 요소가 추가될 수 있습니다.
    5. 렌더 트리를 구성하고 페인트 프로우 과정을 거쳐 사용자들에게 화면을 보여준다.
    
    ```

- Q. CSR의 장단점

    ```
    장점
    - 필요한 부분만 렌더링하기 때문에 자연스러운 사용자 경험을 제공한다.
    - 필요한 리소스만 부분적으로 로딩되기 때문에 성능이 높아질 수 있다.

    단점
    - javascript 파일을 번들링해서 한 번에 받기 때문에 초기 구동 속도가 느리다.
    - 검색엔진최적화가 어렵다.

    ```

- Q. CSR과 SSR의 상호보안

    ```
    next.js를 사용하면 두 개의 장점만을 이용할 수 있다.

    next.js의 SSR

    [pre-rendering]
    1. 서버에서 `ReactDomServer.renderToString` 라는 함수를 사용하여 페이지에 대한 html 문서를 문자열로 가져오라고 합니다.
    2. html 문서에서 react가 동작하여 필요한 js 파일들을 불러올 수 있도록 하는 최소한의 script 태그들이 포함된 상태입니다.
    
    [pre-rendering한 html 문서를 전달]
    1. next.js는 요청온 브라우저에게 Pre-Rendering 한 html 문서를 제공합니다.

    [클라이언트에서 Rendering 시작]
    브라우저는 서버 사이드에서 받은 html 문서를 화면에 렌더링하기 시작합니다. 그리고 html 문서에 존재하는 script 태그에 명시된 js 파일을 로드하고 실행시킵니다. 

    사용자가 해당 페이지에서 다른 페이지로 이동할때는 Next.js에 서버가 아닌 브라우저에서 처리하여 이동하게 한다. (CSR 방식)

    ```
- Q. getStaticProps vs getServerSideProps 

    ```
    getStaticProps 함수는 빌드 시 실행되고 외부 데이터를 가져와 페이지 컴포넌트 내부에서 props로 받아올 수 있습니다.
    페이지 이동간에 호출되지 않는다.
    -> 잘 바뀌지 않는 데이터!
    -> 이것을 사용하면 SSR, CSR 혼합하여 사용할 수 았다.


    getServerSideProps 함수는 빌드 시가 아닌 요청 시마다 외부 데이터를 패치해야 하는 경우 서버사이드 렌더링을 이용합니다.

    ```


- Q. Next.js를 선택하기 위해 고려해야 하는 부분

    ```
    Next.js 단점을 단편적으로 찾기 어려웠다.
    그렇다면 Next.js 도입이 무조건적으로 좋은 선택일까?
    
    라이버리나 프레임워크의 사용목적은 개발 생산성에 있습니다. 이러한 과점에서 라이브러리와 프레임워크의 도입이 중요합니다. 하지만, 대국민 서비스를 제공하는 상황에서는 개발의 생산성 뿐만 아니라 운영 리스크에 대해서 고민해 보아야 합니다.

    안전성, 투명성

    1. 사전에 문제를 빠르게 인지하고 검증할 수 있는가?
    2. 문제 발생시 쉽고 효과적으로 해결할 수 있는가?
    3. 다양한 상황에서 충분한 검증이 이루어졌는가

    프레임워크는 많은 추상화와 규칙을 적용하여 개발자가 제어하기 어려운 부분이 있을 수 있습니다. 이로 인해 프레임워크의 동작 방식과 제한 사항을 완전히 이해하지 못하면 예상치 못한 문제가 발생할 수 있습니다. 또한 프레임워크의 업데이트나 버전 업그레이드에 대한 의존성도 존재하며, 이를 관리하기 위해서는 지속적인 업데이트와 테스트가 필요합니다.
    
    ```

- Q. 두 가지 요소
    ```
     1. 화면에 보여주는 시점
     2. 인터렉티브한 동작을 수행 가능 시점
    
    ```


- Q. Next.js는 어떻게 서버사이드 렌더링을 구성할까?
    ```
    미해결
    ```
    

- Q. 서버에서 렌더링 되어 오는 html 은 어떤 모습의 형태일까? 차이점을 구분할 수 있을까?
  ```
  미해결
  ```


- Q. node.js와 express.js를 활용한 SSR 구현

    ```
    미해결
    ```

